{cat(" \n")
cat("ERROR: WZMATRIX is not the correct length or is otherwise invalid. \n")}
if (errcode[i,1]==20)
{cat(" \n")
cat("ERROR: A path fixed at zero cannot be moderated. \n")}
if (errcode[i,1]==60)
{cat(" \n")
cat("PROCESS is now ready for use.\n")
cat("Copyright 2020-2023 by Andrew F. Hayes ALL RIGHTS RESERVED\n")
cat("Workshop schedule at http://haskayne.ucalgary.ca/CCRAM\n \n")}
if (errcode[i,1]==21)
{cat(" \n")
cat("ERROR: If only one moderator is specified, it must be specified as W. \n")}
if (errcode[i,1]==22)
{cat(" \n")
cat("ERROR: In BMATRIX, X must be specified to affect at least one variable. \n")}
if (errcode[i,1]==23)
{cat(" \n")
cat("ERROR: In BMATRIX, at least one variable must be specified to affect Y. \n")}
if (errcode[i,1]==24)
{cat(" \n")
cat("ERROR: You must specify a model number or a custom BMATRIX specification. \n")}
if (errcode[i,1]==25)
{cat(" \n")
cat("ERROR: BMATRIX cannot be used in conjunction with a model number. \n")}
if (errcode[i,1]==26)
{cat(" \n")
cat("ERROR: Your model has a dangling mediator (all Ms must affect and be affected). \n")}
if (errcode[i,1]==29)
{cat(" \n")
cat("ERROR: CMATRIX is not the correct length or is otherwise invalid. \n")}
if (errcode[i,1]==30)
{cat(" \n")
cat("ERROR: In CMATRIX, all covariates must be assigned to an M or a Y. \n")}
if ((errcode[i,1]==31) & (singlr==0))
{cat(" \n")
singlr<-1
cat("ERROR: A linear or near linear dependence (singularity) exists in the data. \n")}
if (errcode[i,1]==32)
{cat(" \n")
cat("ERROR: Models 80 and 81 require between 3 and 6 mediators. \n")}
if (errcode[i,1]==33)
{cat(" \n")
cat("ERROR: Model 82 requires 4 mediators. \n")}
if (errcode[i,1]==34)
{cat(" \n")
cat("ERROR: This model number requires between 2 and 6 mediators. \n")}
if (errcode[i,1]==35)
{cat(" \n")
cat("ERROR: In a model with only one moderator, that moderator must be W. \n")}
if (errcode[i,1]==36)
{cat(" \n")
cat("ERROR: A serial mediation model cannot have more than 6 mediators. \n")}
if (errcode[i,1]==37)
{cat(" \n")
cat("ERROR: No more than 10 mediators are allowed in a PROCESS command. \n")}
if (errcode[i,1]==38)
{cat(" \n")
cat("ERROR: XCATCODE is not provided, not the correct length, or is otherwise invalid. \n")}
if (errcode[i,1]==39)
{cat(" \n")
cat("ERROR: WCATCODE is not provided, not the correct length, or is otherwise invalid. \n")}
if (errcode[i,1]==40)
{cat(" \n")
cat("ERROR: ZCATCODE is not provided, not the correct length, or is otherwise invalid. \n")}
if (errcode[i,1]==41)
{cat(" \n")
cat("ERROR: Models 1, 2, and 3 cannot be customized. \n")}
if (errcode[i,1]==43)
{cat(" \n")
cat("ERROR: PROCESS does not allow dichotomous mediators. \n")}
if (errcode[i,1]==50)
{cat(" \n")
cat("ERROR: A multicategorical moderator cannot be specified as a covariate. \n")}
if (errcode[i,1]==51)
{cat(" \n")
cat("ERROR: A variable you specified as a covariate is a moderator in all equations. \n")}
if (errcode[i,1]==62)
{cat(" \n")
cat("ERROR: After listwise deletion of cases with missing data, too few cases remain. \n")}
if (errcode[i,1]==63)
{cat(" \n")
cat("ERROR: The XMINT option is available only for model 4. \n")}
if (errcode[i,1]==64)
{cat(" \n")
cat("ERROR: Incorrect number of values specified in CDEVAL option. \n")}
if (errcode[i,1]==65)
{cat(" \n")
cat("ERROR: Only indicator or sequential coding of X is allowed with the XMINT option. \n")}
if (errcode[i,1]==66)
{cat(" \n")
cat("ERROR: A reference value of X is required for this model. \n")}
if (errcode[i,1]==67)
{cat(" \n")
cat("ERROR: Too many elements provided in XREFVAL option. \n")}
if (errcode[i,1]==68)
{cat(" \n")
cat("ERROR: Covariate assignment is not allowed with the XMINT option. \n")}
if (errcode[i,1]==69)
{cat(" \n")
cat("ERROR: Incorrect number of values specified in COVAL option. \n")}
if (errcode[i,1]==70)
{cat(" \n")
cat("ERROR: Incorrect value(s) in XREFVAL for this dichotomous X variable. \n")}
if (errcode[i,1]==71)
{cat(" \n")
cat("ERROR: The CENTER option is not available when using the XMINT option. \n")}
if (errcode[i,1]==72)
{cat(" \n")
cat("ERROR: The XMINT option is not available for models with a dichotomous Y. \n")}
if ((errcode[i,1]==52) & (mcerpt==0))
{mcerpt<-1
cat(" \n")
cat("ERROR: A variable specified as multicategorical must have at least three categories. \n")}
if (errcode[i,1]==53)
{cat(" \n")
cat("ERROR: Variables declared as factors or that are non-numeric are not accepted by PROCESS.\n")}
}
#if (saveboot==1)
#{resultm<-list(resultm,boots)}
#invisible(resultm)
resultms<-NULL
if ((saveboot==0) & (saveest==1)){resultms<-resultm}
if ((saveboot==1) & (saveest==0)){resultms<-boots}
if ((saveboot==1) & (saveest==1)){resultms<-(list(boots,resultm))}
invisible(resultms)
}
process(activate=1)
library(psych)
library(easystats)
library(sjPlot)
library(mediation)
library(see)
library(tidyverse)
glbwarm<-read.table("glbwarm.csv", sep=",",header=TRUE) ## installere datasettet
setwd("C:/Users/holst/OneDrive - UiT Office 365/Documents/Alt relatert til studier/Forskerlinje/PHD emner/CDP919/hayes2022data/glbwarm")
glbwarm<-read.table("glbwarm.csv", sep=",",header=TRUE) ## installere datasettet
names(glbwarm)
str(glbwarm)
head(glbwarm)
psych::describe(glbwarm) ## deskreptive beskrivelse av datasettet
## gjør en korrelasjonsanayse
results <- correlation(glbwarm)
results
summary(results)
## plotter korrelasjonene
results %>%
summary(redundant = FALSE) %>%
plot()
mod1 <- lm(govact ~ negemot + posemot + age + sex + ideology, data= glbwarm)
summary(mod1) # får ut resultatene
library(interactions)
library(jtools)
library(ggplot2)
library(psych)
library(sjPlot)
glbwarm<-read.table("glbwarm.csv", sep=",",header=TRUE)
head(glbwarm)
str(glbwarm)
names(glbwarm)
psych::describe(glbwarm, skew =FALSE)
mod3.5 <- lm(govact ~ negemot + age + negemot*age + posemot + ideology + sex,data=glbwarm)
summary(mod3.5)
mod3.5 <- lm(govact ~ negemot + age + posemot + ideology + sex,data=glbwarm)
summary(mod3.5)
mod3.5 <- lm(govact ~ negemot + age + negemot*age + posemot + ideology + sex,data=glbwarm)
summary(mod3.5)
tab_model(mod3.5, show.stat = TRUE, show.df = TRUE)
interact_plot(mod3.5, pred =negemot , modx = age, interval = TRUE) # interaksjonsplot
sim_slopes(mod3.5, pred =negemot, modx = age, johnson_neyman = FALSE)
sim_slopes(mod3.5, pred =negemot , modx = age, johnson_neyman = TRUE)
johnson_neyman(mod3.5, pred =negemot , modx = age, alpha = .05)
pA <- probe_interaction(mod3.5, pred =negemot , modx = age, cond.int = TRUE,
interval = TRUE,  jnplot = TRUE)
pA  # summary av probe interaction
pA[1] #J-M-plot
pA[2] # interaksjonsplot
process(data=glbwarm,y="govact",x="negemot",w="age",cov=c("posemot","ideology","sex"),model=1,jn=1,plot=1)
process(data=glbwarm,y="govact",x="negemot",w="age",cov=c("posemot","ideology","sex"),model=1,jn=1,plot=1,wmodval=c(30,50,70))
library(psych)
library(easystats)
library(sjPlot)
library(mediation)
library(see)
library(tidyverse)
teams<-read.table("teams.csv", sep=",",header=TRUE)
setwd("C:/Users/holst/OneDrive - UiT Office 365/Documents/Alt relatert til studier/Forskerlinje/PHD emner/CDP919/hayes2022data/teams")
teams<-read.table("teams.csv", sep=",",header=TRUE)
head(teams)
str(teams)
names(teams)
describe(teams, skew=FALSE) ## deskreptiv
## en interaksjonsmodell (uten X)
modMWY <- lm(perform~ negtone*negexp,data=teams)
summary(modMWY)
interact_plot(modMWY, pred =negtone , modx = negexp)
sim_slopes(modMWY, pred =negtone , modx = negexp, johnson_neyman = FALSE)
sim_slopes(modMWY, pred =negtone , modx = negexp, johnson_neyman = TRUE)
johnson_neyman(modMWY, pred =negtone , modx = negexp, alpha = .05)
probe_interaction(modMWY, pred =negtone , modx = negexp, cond.int = TRUE,
interval = TRUE,  jnplot = TRUE)
## proces modell tilsvarende over
process(data=teams,y="perform",x="negtone",w="negexp",cov="dysfunc",model=1,plot=1, jn=1)
## proces modell tilsvarende over
process(data=teams,y="perform",x="negtone",w="negexp",cov="dysfunc",model=1,plot=1, jn=1)
## moderert mediering
process(data=teams,y="perform",x="dysfunc",m="negtone",w="negexp",model=14,plot=1,seed=42517)
## moderert mediering
process(data=teams,y="perform",x="dysfunc",m="negtone",w="negexp",model=14,plot=1,jn=1,seed=42517)
# Visualisere direkte og indirekte effekter
x<-c(0,1,0,1,0,1)
w<-c(-0.531,-0.531,-0.060,-0.060,0.600,0.600)
y<-c(0.366,-0.161,0.366,-0.405,0.366,-0.746)
plot(y=y,x=w,pch=15,col="white",
xlab="Nonverbal negative expressivity",
ylab="Effect of dysfunctional team behavior")
legend.txt<-c("Direct effect","Indirect effect")
legend("bottomleft",legend=legend.txt,lty=c(1,3),lwd=c(4,3))
lines(w[x==0],y[x==0],lwd=4,lty=1)
lines(w[x==1],y[x==1],lwd=4,lty=3)
abline(0,0,lwd=0.5,lty=2)
library(haven)
library(psych)
library(ggplot2)
library(stats)
library(car)
library(apaTables)
library(modelsummary)
library(ggplot2)
library(lm.beta)
library(lme4)
library(dplyr)
library(haven)
library(psych)
library(ggplot2)
library(stats)
library(car)
library(apaTables)
library(modelsummary)
library(ggplot2)
library(lm.beta)
library(lme4)
library(dplyr)
data_raw <- read_sav("data/forskerlinje_friskestudenter_rettet_16_april.sav")
options(max.print = 2500)
describe(data_raw)
model <- manova(cbind(BRIEF_AI_T, BRIEF_MI_T) ~ as.factor(KJONN) + agree +
consci + neuro + BDIsum + BAIsum + SumbisNoFour,
data = data_raw)
data_raw |>
mutate(
across(c(BRIEF_AI_T, BRIEF_MI_T, consci, agree, open, extra, neuro,
BDIsum, BAIsum, SumbisNoFour), scale), .before=1) ->
data
################################################################################
# Multivariate resultater med type 3 ss med Car
model_2 <- manova(cbind(BRIEF_AI_T, BRIEF_MI_T) ~ as.factor(KJONN) + agree +
consci + neuro + BDIsum + BAIsum + SumbisNoFour,
data = data_raw)
Anova(model_2, type = "III")
# Univariate resultatet
lm_BRIEF_AI_T <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci +
neuro + BDIsum + BAIsum + SumbisNoFour, data = data_raw)
lm_BRIEF_MI_T <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro +
BDIsum + BAIsum + SumbisNoFour, data = data_raw)
anova_BRIEF_AI_T <- Anova(lm_BRIEF_AI_T, type="III")
anova_BRIEF_MI_T <- Anova(lm_BRIEF_MI_T, type="III")
print(anova_BRIEF_AI_T)
print(anova_BRIEF_MI_T)
# Parameter estimates
summary(lm_BRIEF_AI_T)
summary(lm_BRIEF_MI_T)
library(boot)
######
# Bootstrap
# Function to obtain model coefficients
boot_function <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
# Fit models on the resampled data
model_AI <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
model_MI <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
# Return the coefficients (or any other statistic)
c(coef(model_AI), coef(model_MI))
}
# Set the number of bootstrap replicates
n_bootstraps <- 5000
# Perform bootstrap for BRIEF_AI_T and BRIEF_MI_T models
boot_results <- boot(data = data_raw, statistic = boot_function, R = n_bootstraps)
# Print the results
print(boot_results)
# Basic summary of bootstrap results
boot_summary <- boot.ci(boot_results, type = c("perc", "bca"))
print(boot_summary)
######
# Bootstrap function for the BRIEF_AI_T model
boot_function_AI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
return(coef(model))  # You can adjust this to return other statistics
}
# Bootstrap function for the BRIEF_MI_T model
boot_function_MI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
return(coef(model))  # You can adjust this to return other statistics
}
# Set the number of bootstrap replicates
n_bootstraps <- 5000
# Perform bootstrap for the BRIEF_AI_T model
boot_results_AI <- boot(data = data_raw, statistic = boot_function_AI, R = n_bootstraps)
# Perform bootstrap for the BRIEF_MI_T model
boot_results_MI <- boot(data = data_raw, statistic = boot_function_MI, R = n_bootstraps)
# Summary of bootstrap results for the BRIEF_AI_T model
boot_summary_AI <- boot.ci(boot_results_AI, type = c("norm", "basic", "perc", "bca"))
print(boot_summary_AI)
# Summary of bootstrap results for the BRIEF_MI_T model
boot_summary_MI <- boot.ci(boot_results_MI, type = c("norm", "basic", "perc", "bca"))
print(boot_summary_MI)
######
# Bootstrap function for the BRIEF_AI_T model
boot_function_AI_pvalues <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
summary_model <- summary(model)
return(summary_model$coefficients[, 4])  # Extract p-values
}
# Bootstrap function for the BRIEF_MI_T model
boot_function_MI_pvalues <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
summary_model <- summary(model)
return(summary_model$coefficients[, 4])  # Extract p-values
}
# Set the number of bootstrap replicates
n_bootstraps <- 5000
# Perform bootstrap for the BRIEF_AI_T model
boot_results_AI_pvalues <- boot(data = data_raw, statistic = boot_function_AI_pvalues, R = n_bootstraps)
# Perform bootstrap for the BRIEF_MI_T model
boot_results_MI_pvalues <- boot(data = data_raw, statistic = boot_function_MI_pvalues, R = n_bootstraps)
# Function to calculate the proportion of significant p-values
calculate_significance_proportion <- function(boot_pvalues, level = 0.05) {
sapply(boot_pvalues$t, function(p) mean(p < level))
}
# Calculate significance proportions for each predictor in BRIEF_AI_T model
significance_proportions_AI <- calculate_significance_proportion(boot_results_AI_pvalues)
print("Proportion of significant p-values for BRIEF_AI_T model:")
print(significance_proportions_AI)
# Calculate significance proportions for each predictor in BRIEF_MI_T model
significance_proportions_MI <- calculate_significance_proportion(boot_results_MI_pvalues)
print("Proportion of significant p-values for BRIEF_MI_T model:")
print(significance_proportions_MI)
######
# Bootstrap function for the BRIEF_AI_T model
boot_function_AI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
return(p_values)
}
# Bootstrap function for the BRIEF_MI_T model
boot_function_MI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
return(p_values)
}
# Set the number of bootstrap replicates
n_bootstraps <- 5000
# Perform bootstrap for the BRIEF_AI_T model
boot_results_AI <- boot(data = data_raw, statistic = boot_function_AI, R = n_bootstraps)
# Perform bootstrap for the BRIEF_MI_T model
boot_results_MI <- boot(data = data_raw, statistic = boot_function_MI, R = n_bootstraps)
# Calculate 95% Confidence Intervals for the p-values from the BRIEF_AI_T model
ci_p_values_AI <- apply(boot_results_AI$t, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
# Calculate 95% Confidence Intervals for the p-values from the BRIEF_MI_T model
ci_p_values_MI <- apply(boot_results_MI$t, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
# Print the confidence intervals
print("Confidence Intervals for P-values (BRIEF_AI_T):")
print(ci_p_values_AI)
print("Confidence Intervals for P-values (BRIEF_MI_T):")
print(ci_p_values_MI)
######
# Bootstrap function for the BRIEF_AI_T model with predictor names
boot_function_AI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
names <- rownames(summary(model)$coefficients)  # Extract predictor names
return(cbind(names, p_values))  # Combine names and p-values
}
# Bootstrap function for the BRIEF_MI_T model with predictor names
boot_function_MI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
names <- rownames(summary(model)$coefficients)  # Extract predictor names
return(cbind(names, p_values))  # Combine names and p-values
}
# Perform bootstrap for the BRIEF_AI_T model
boot_results_AI <- boot(data = data_raw, statistic = boot_function_AI, R = 5000)
# Perform bootstrap for the BRIEF_MI_T model
boot_results_MI <- boot(data = data_raw, statistic = boot_function_MI, R = 5000)
# Calculate 95% Confidence Intervals for the p-values from the BRIEF_AI_T model
ci_p_values_AI <- apply(boot_results_AI$t[, 2, drop = FALSE], 2, function(x) quantile(as.numeric(x), probs = c(0.025, 0.975)))
######
# Bootstrap function for the BRIEF_AI_T model with numeric p-values
boot_function_AI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
return(as.numeric(p_values))  # Ensure p-values are numeric
}
# Bootstrap function for the BRIEF_MI_T model with numeric p-values
boot_function_MI <- function(data, indices) {
data_sample <- data[indices, ]  # Resample the data
model <- lm(BRIEF_MI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = data_sample)
p_values <- summary(model)$coefficients[, 4]  # Extract p-values
return(as.numeric(p_values))  # Ensure p-values are numeric
}
# Perform bootstrap for the BRIEF_AI_T model
boot_results_AI <- boot(data = data_raw, statistic = boot_function_AI, R = 5000)
# Perform bootstrap for the BRIEF_MI_T model
boot_results_MI <- boot(data = data_raw, statistic = boot_function_MI, R = 5000)
# Calculate 95% Confidence Intervals for the p-values from the BRIEF_AI_T model
ci_p_values_AI <- apply(boot_results_AI$t, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
# Calculate 95% Confidence Intervals for the p-values from the BRIEF_MI_T model
ci_p_values_MI <- apply(boot_results_MI$t, 2, function(x) quantile(x, probs = c(0.025, 0.975)))
# Print the confidence intervals with predictor names for BRIEF_AI_T
cat("Confidence Intervals for P-values (BRIEF_AI_T):\n")
print(data.frame(Predictor = predictor_names, CI_Lower = ci_p_values_AI[1,], CI_Upper = ci_p_values_AI[2,]))
# Extract predictor names from the model
predictor_names_AI <- names(coef(lm_BRIEF_AI_T))
predictor_names_MI <- names(coef(lm_BRIEF_MI_T))
# Print the confidence intervals with predictor names for BRIEF_AI_T
cat("Confidence Intervals for P-values (BRIEF_AI_T):\n")
print(data.frame(Predictor = predictor_names_AI, CI_Lower = ci_p_values_AI[1,], CI_Upper = ci_p_values_AI[2,]))
# Print the confidence intervals with predictor names for BRIEF_MI_T
cat("Confidence Intervals for P-values (BRIEF_MI_T):\n")
print(data.frame(Predictor = predictor_names_MI, CI_Lower = ci_p_values_MI[1,], CI_Upper = ci_p_values_MI[2,]))
library(boot)
# Define a simple bootstrap function that returns coefficients
boot_coef <- function(data, indices) {
resampled_data <- data[indices, ]
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = resampled_data)
return(coef(model))
}
# Perform the bootstrap
set.seed(123)  # for reproducibility
results <- boot(data_raw, statistic = boot_coef, R = 1000)
# Calculate percentile confidence intervals
ci <- boot.ci(results, type = "perc")
# Print the confidence intervals
print(ci)
library(boot)
# Define a simple bootstrap function that returns coefficients
boot_coef <- function(data, indices) {
resampled_data <- data[indices, ]
model <- lm(BRIEF_AI_T ~ as.factor(KJONN) + agree + consci + neuro + BDIsum + BAIsum + SumbisNoFour, data = resampled_data)
return(coef(model))
}
# Perform the bootstrap
set.seed(123)  # for reproducibility
results <- boot(data_raw, statistic = boot_coef, R = 1000)
# Calculate percentile confidence intervals
ci <- boot.ci(results, type = "perc")
# Print the confidence intervals
print(ci)
library(haven)
library(psych)
library(ggplot2)
library(dplyr)
library(rwa)
data <- read_sav("data/forskerlinje_friskestudenter_rettet_16_april.sav")
# Rename variables
names(data)[names(data) == "KJONN"] <- "Sex"
names(data)[names(data) == "SumbisNoFour"] <- "Insomnia"
names(data)[names(data) == "consci"] <- "Conscientiousness"
names(data)[names(data) == "agree"] <- "Agreeableness"
names(data)[names(data) == "open"] <- "Openness"
names(data)[names(data) == "extra"] <- "Extraversion"
names(data)[names(data) == "neuro"] <- "Neuroticism"
names(data)[names(data) == "BAIsum"] <- "Anxiety"
names(data)[names(data) == "BDIsum"] <- "Depression"
options(max.print = 2500)
describe(data)
fit <- lm(cbind(BRIEF_AI_T, BRIEF_MI_T) ~ as.factor(Sex) +
Agreeableness + Conscientiousness + Neuroticism +
Depression + Anxiety + Insomnia, data = data)
Sex <- as.numeric(data$Sex)
# Relative weight analysis
behaviour <- data %>%
rwa(outcome = "BRIEF_AI_T",
predictors = c("Sex", "Agreeableness", "Conscientiousness",
"Neuroticism", "Depression", "Anxiety", "Insomnia"),
applysigns = TRUE,
plot = TRUE)
meta <- data %>%
rwa(outcome = "BRIEF_MI_T",
predictors = c("Sex", "Agreeableness", "Conscientiousness",
"Neuroticism", "Depression", "Anxiety", "Insomnia"),
applysigns = T,
plot = T)
behaviour
meta
Sex <- as.factor(data$Sex)
# Relative weight analysis
behaviour <- data %>%
rwa(outcome = "BRIEF_AI_T",
predictors = c("Sex", "Agreeableness", "Conscientiousness",
"Neuroticism", "Depression", "Anxiety", "Insomnia"),
applysigns = TRUE,
plot = TRUE)
